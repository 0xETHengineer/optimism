{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { OptimismPortal } from \"./OptimismPortal.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\n\n/**\n * @title L1CrossDomainMessenger\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages\n * from L2 onto L1.\n * This contract should be deployed behind an upgradable proxy\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /**\n     * @notice Address of the OptimismPortal.\n     */\n    OptimismPortal public portal;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice Initialize the L1CrossDomainMessenger\n     * @param _portal The OptimismPortal\n     */\n    function initialize(OptimismPortal _portal) external {\n        portal = _portal;\n\n        address[] memory blockedSystemAddresses = new address[](1);\n        blockedSystemAddresses[0] = address(this);\n\n        _initialize(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER, blockedSystemAddresses);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Ensure that the L1CrossDomainMessenger can only be called\n     * by the OptimismPortal and the L2 sender is the L2CrossDomainMessenger.\n     */\n    function _isSystemMessageSender() internal view override returns (bool) {\n        return msg.sender == address(portal) && portal.l2Sender() == otherMessenger;\n    }\n\n    /**\n     * @notice Sending a message in the L1CrossDomainMessenger involves\n     * depositing through the OptimismPortal.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        portal.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "contracts/L1/OptimismPortal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\nimport { AddressAliasHelper } from \"@eth-optimism/contracts/standards/AddressAliasHelper.sol\";\nimport { ExcessivelySafeCall } from \"../libraries/ExcessivelySafeCall.sol\";\n\n/**\n * @title OptimismPortal\n * This contract should be deployed behind an upgradable proxy.\n */\ncontract OptimismPortal {\n    /**********\n     * Errors *\n     **********/\n\n    /**\n     * @notice Error emitted when the output root proof is invalid.\n     */\n    error InvalidOutputRootProof();\n\n    /**\n     * @notice Error emitted when the withdrawal inclusion proof is invalid.\n     */\n    error InvalidWithdrawalInclusionProof();\n\n    /**\n     * @notice Error emitted when a withdrawal has already been finalized.\n     */\n    error WithdrawalAlreadyFinalized();\n\n    /**\n     * @notice Error emitted on deposits which create a new contract with a non-zero target.\n     */\n    error NonZeroCreationTarget();\n\n    /**********\n     * Events *\n     **********/\n\n    /**\n     * @notice Emitted when a Transaction is deposited from L1 to L2. The parameters of this\n     * event are read by the rollup node and used to derive deposit transactions on L2.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    /**\n     * @notice Emitted when a withdrawal is finalized\n     */\n    event WithdrawalFinalized(bytes32 indexed, bool success);\n\n    /*************\n     * Constants *\n     *************/\n\n    /**\n     * @notice Value used to reset the l2Sender, this is more efficient than setting it to zero.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /*************\n     * Variables *\n     *************/\n\n    /**\n     * @notice Minimum time that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD;\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Public variable which can be used to read the address of the L2 account which\n     * initated the withdrawal. Can also be used to determine whether or not execution is occuring\n     * downstream of a call to finalizeWithdrawalTransaction().\n     */\n    address public l2Sender = DEFAULT_L2_SENDER;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     * Used for replay protection.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(L2OutputOracle _l2Oracle, uint256 _finalizationPeriod) {\n        L2_ORACLE = _l2Oracle;\n        FINALIZATION_PERIOD = _finalizationPeriod;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and\n     * have the funds be deposited to their address on L2.\n     * @dev This is intended as a convenience function for EOAs. Contracts should call the\n     * depositTransaction() function directly.\n     */\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, 100000, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     * deriving deposit transactions.\n     * @param _to The L2 destination address.\n     * @param _value The ETH value to send in the deposit transaction.\n     * @param _gasLimit The L2 gasLimit.\n     * @param _isCreation Whether or not the transaction should be contract creation.\n     * @param _data The input data.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable {\n        // Differentiate between sending to address(0)\n        // and creating a contract\n        if (_isCreation && _to != address(0)) {\n            revert NonZeroCreationTarget();\n        }\n\n        address from = msg.sender;\n        // Transform the from-address to its alias if the caller is a contract.\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        emit TransactionDeposited(from, _to, msg.value, _value, _gasLimit, _isCreation, _data);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     * @param _nonce Nonce for the provided message.\n     * @param _sender Message sender address on L2.\n     * @param _target Target address on L1.\n     * @param _value ETH to send to the target.\n     * @param _gasLimit Gas to be forwarded to the target.\n     * @param _data Data to send to the target.\n     * @param _l2Timestamp L2 timestamp of the outputRoot.\n     * @param _outputRootProof Inclusion proof of the withdrawer contracts storage root.\n     * @param _withdrawalProof Inclusion proof for the given withdrawal in the withdrawer contract.\n     */\n    function finalizeWithdrawalTransaction(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data,\n        uint256 _l2Timestamp,\n        WithdrawalVerifier.OutputRootProof calldata _outputRootProof,\n        bytes calldata _withdrawalProof\n    ) external payable {\n        // Prevent reentrency\n        require(_target != address(this), \"Cannot send message to self.\");\n\n        // Get the output root.\n        L2OutputOracle.OutputProposal memory proposal = L2_ORACLE.getL2Output(_l2Timestamp);\n\n        // Ensure that enough time has passed since the proposal was submitted\n        // before allowing a withdrawal. A fault proof should be submitted\n        // before this check is allowed to pass.\n        require(\n            block.timestamp > proposal.timestamp + FINALIZATION_PERIOD,\n            \"Proposal is not yet finalized.\"\n        );\n\n        // Verify that the output root can be generated with the elements in the proof.\n        if (proposal.outputRoot != WithdrawalVerifier._deriveOutputRoot(_outputRootProof)) {\n            revert InvalidOutputRootProof();\n        }\n\n        // Verify that the hash of the withdrawal transaction's arguments are included in the\n        // storage hash of the withdrawer contract.\n        bytes32 withdrawalHash = WithdrawalVerifier.withdrawalHash(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // Verify proof that a withdrawal on L2 was initated\n        if (\n            WithdrawalVerifier._verifyWithdrawalInclusion(\n                withdrawalHash,\n                _outputRootProof.withdrawerStorageRoot,\n                _withdrawalProof\n            ) == false\n        ) {\n            revert InvalidWithdrawalInclusionProof();\n        }\n\n        // Check that this withdrawal has not already been finalized.\n        if (finalizedWithdrawals[withdrawalHash] == true) {\n            revert WithdrawalAlreadyFinalized();\n        }\n\n        // Set the withdrawal as finalized\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Save enough gas so that the call cannot use up all of the gas\n        require(gasleft() >= _gasLimit + 20000, \"Insufficient gas to finalize withdrawal.\");\n\n        // Set the l2Sender so that other contracts can know which account\n        // on L2 is making the withdrawal\n        l2Sender = _sender;\n        // Make the call and ensure that a contract cannot out of gas\n        // us by returning a huge amount of data\n        (bool success, ) = ExcessivelySafeCall.excessivelySafeCall(\n            _target,\n            _gasLimit,\n            _value,\n            0,\n            _data\n        );\n        // Be sure to reset the l2Sender\n        l2Sender = DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// solhint-disable max-line-length\n\n/* Library Imports */\nimport {\n    Lib_DefaultValues\n} from \"@eth-optimism/contracts/libraries/constants/Lib_DefaultValues.sol\";\nimport { CrossDomainHashing } from \"../libraries/Lib_CrossDomainHashing.sol\";\n\n/* External Imports */\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ExcessivelySafeCall } from \"../libraries/ExcessivelySafeCall.sol\";\n\n// solhint-enable max-line-length\n\n/**\n * @title CrossDomainMessenger\n * @dev The CrossDomainMessenger contract delivers messages between two layers.\n */\nabstract contract CrossDomainMessenger is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Constants *\n     *************/\n\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    uint32 public constant MIN_GAS_DYNAMIC_OVERHEAD = 1;\n\n    uint32 public constant MIN_GAS_CONSTANT_OVERHEAD = 100000;\n\n    /*************\n     * Variables *\n     *************/\n\n    // blockedMessages in old L1CrossDomainMessenger\n    bytes32 internal REMOVED_VARIABLE_SPACER_1;\n\n    // relayedMessages in old L1CrossDomainMessenger\n    bytes32 internal REMOVED_VARIABLE_SPACER_2;\n\n    /// @notice Mapping of message hash to boolean success value.\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /// @notice Current x-domain message sender.\n    address internal xDomainMsgSender;\n\n    /// @notice Nonce for the next message to be sent.\n    uint256 internal msgNonce;\n\n    /// @notice Address of the CrossDomainMessenger on the other chain.\n    address public otherMessenger;\n\n    /// @notice Mapping of message hash to boolean receipt value.\n    mapping(bytes32 => bool) public receivedMessages;\n\n    /// @notice Blocked system addresses that cannot be called (for security reasons).\n    mapping(address => bool) public blockedSystemAddresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Pause relaying.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Retrieves the address of the x-domain message sender. Will throw an error\n     * if the sender is not currently set (equal to the default sender).\n     * This function is meant to be called on the remote side of a cross domain\n     * message so that the account that initiated the call can be known.\n     *\n     * @return Address of the x-domain message sender.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * Retrieves the next message nonce. Adds the hash version to the nonce.\n     *\n     * @return Next message nonce with added hash version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return CrossDomainHashing.addVersionToNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * Base amount of gas required to make sure that the message will be received without\n     * running out of gas. Amount of gas provided to the L2 call will be the gas requested by\n     * the user PLUS this gas value so that if the message is not successful, it can always be\n     * replayed on the other end.\n     *\n     * @param _message Message to compute base gas for.\n     * @return Base gas required for message.\n     */\n    function baseGas(bytes memory _message) public pure returns (uint32) {\n        // TODO: Values here are meant to be good enough to get a devnet running. We need to do\n        // some simple experimentation with the smallest and largest possible message sizes to find\n        // the correct constant and dynamic overhead values.\n        return (uint32(_message.length) * MIN_GAS_DYNAMIC_OVERHEAD) + MIN_GAS_CONSTANT_OVERHEAD;\n    }\n\n    /**\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _minGasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            otherMessenger,\n            _minGasLimit + baseGas(_message),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable nonReentrant whenNotPaused {\n        bytes32 versionedHash = CrossDomainHashing.getVersionedHash(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isSystemMessageSender()) {\n            // Should never happen.\n            require(msg.value == _value, \"Mismatched message value.\");\n        } else {\n            // TODO(tynes): could require that msg.value == 0 here\n            // to prevent eth from getting stuck\n            require(receivedMessages[versionedHash], \"Message cannot be replayed.\");\n        }\n\n        // TODO: Should blocking happen on sending or receiving side?\n        // TODO: Should this just return with an event instead of reverting?\n        require(\n            blockedSystemAddresses[_target] == false,\n            \"Cannot send message to blocked system address.\"\n        );\n\n        require(successfulMessages[versionedHash] == false, \"Message has already been relayed.\");\n\n        // TODO: Make sure this will always give us enough gas.\n        require(gasleft() >= _minGasLimit + 45000, \"Insufficient gas to relay message.\");\n\n        xDomainMsgSender = _sender;\n        (bool success, ) = ExcessivelySafeCall.excessivelySafeCall(\n            _target,\n            gasleft() - 40000,\n            _value,\n            0,\n            _message\n        );\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        if (success == true) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            receivedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _isSystemMessageSender() internal view virtual returns (bool);\n\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * Initializes the contract.\n     */\n    function _initialize(address _otherMessenger, address[] memory _blockedSystemAddresses)\n        internal\n        initializer\n    {\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n        otherMessenger = _otherMessenger;\n\n        for (uint256 i = 0; i < _blockedSystemAddresses.length; i++) {\n            blockedSystemAddresses[_blockedSystemAddresses[i]] = true;\n        }\n\n        // TODO: ensure we know what these are doing and why they are here\n        // Initialize upgradable OZ contracts\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title L2OutputOracle\n * @notice The L2 state is committed to in this contract\n * The payable keyword is used on appendL2Output to save gas on the msg.value check.\n * This contract should be deployed behind an upgradable proxy\n */\n// slither-disable-next-line locked-ether\ncontract L2OutputOracle is Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when an output is appended.\n    event l2OutputAppended(\n        bytes32 indexed _l2Output,\n        uint256 indexed _l1Timestamp,\n        uint256 indexed _l2timestamp\n    );\n\n    /// @notice Emitted when an output is deleted.\n    event l2OutputDeleted(\n        bytes32 indexed _l2Output,\n        uint256 indexed _l1Timestamp,\n        uint256 indexed _l2timestamp\n    );\n\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    /// @notice The interval in seconds at which checkpoints must be submitted.\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /// @notice The time between blocks on L2.\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /// @notice The number of blocks in the chain before the first block in this contract.\n    uint256 public immutable HISTORICAL_TOTAL_BLOCKS;\n\n    /// @notice The timestamp of the first L2 block recorded in this contract.\n    uint256 public immutable STARTING_BLOCK_TIMESTAMP;\n\n    /// @notice The timestamp of the most recent L2 block recorded in this contract.\n    uint256 public latestBlockTimestamp;\n\n    /// @notice A mapping from L2 timestamps to the output root for the block with that timestamp.\n    mapping(uint256 => OutputProposal) internal l2Outputs;\n\n    /// @notice OutputProposal represents a commitment to the L2 state.\n    /// The timestamp is the L1 timestamp that the output root is posted.\n    /// This timestamp is used to verify that the finalization period\n    /// has passed since the output root was submitted.\n    struct OutputProposal {\n        bytes32 outputRoot;\n        uint256 timestamp;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @notice Initialize the L2OutputOracle contract.\n     * @param _submissionInterval The desired interval in seconds at which\n     *        checkpoints must be submitted.\n     * @param _l2BlockTime The desired L2 inter-block time in seconds.\n     * @param _genesisL2Output The initial L2 output of the L2 chain.\n     * @param _historicalTotalBlocks The number of blocks that preceding the\n     *        initialization of the L2 chain.\n     * @param _startingBlockTimestamp The timestamp to start L2 block at.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        bytes32 _genesisL2Output,\n        uint256 _historicalTotalBlocks,\n        uint256 _startingBlockTimestamp,\n        address sequencer\n    ) {\n        require(\n            _submissionInterval % _l2BlockTime == 0,\n            \"Submission Interval must be a multiple of L2 Block Time\"\n        );\n\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        // solhint-disable-next-line not-rely-on-time\n        l2Outputs[_startingBlockTimestamp] = OutputProposal(_genesisL2Output, block.timestamp);\n        HISTORICAL_TOTAL_BLOCKS = _historicalTotalBlocks;\n        // solhint-disable-next-line not-rely-on-time\n        latestBlockTimestamp = _startingBlockTimestamp;\n        // solhint-disable-next-line not-rely-on-time\n        STARTING_BLOCK_TIMESTAMP = _startingBlockTimestamp;\n\n        _transferOwnership(sequencer);\n    }\n\n    /*********************************\n     * External and Public Functions *\n     *********************************/\n\n    /**\n     * @notice Accepts an L2 outputRoot and the timestamp of the corresponding L2 block. The\n     * timestamp must be equal to the current value returned by `nextTimestamp()` in order to be\n     * accepted.\n     * This function may only be called by the Sequencer.\n     * @param _l2Output The L2 output of the checkpoint block.\n     * @param _l2timestamp The L2 block timestamp that resulted in _l2Output.\n     * @param _l1Blockhash A block hash which must be included in the current chain.\n     * @param _l1Blocknumber The block number with the specified block hash.\n     */\n    function appendL2Output(\n        bytes32 _l2Output,\n        uint256 _l2timestamp,\n        bytes32 _l1Blockhash,\n        uint256 _l1Blocknumber\n    ) external payable onlyOwner {\n        require(_l2timestamp < block.timestamp, \"Cannot append L2 output in future\");\n        require(_l2timestamp == nextTimestamp(), \"Timestamp not equal to next expected timestamp\");\n        require(_l2Output != bytes32(0), \"Cannot submit empty L2 output\");\n\n        if (_l1Blockhash != bytes32(0)) {\n            // This check allows the sequencer to append an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the sequencer's submission is censored until the block is no longer\n            // retrievable, if the sequencer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1Blocknumber) == _l1Blockhash,\n                \"Blockhash does not match the hash at the expected height.\"\n            );\n        }\n\n        l2Outputs[_l2timestamp] = OutputProposal(_l2Output, block.timestamp);\n        latestBlockTimestamp = _l2timestamp;\n\n        emit l2OutputAppended(_l2Output, block.timestamp, _l2timestamp);\n    }\n\n    /**\n     * @notice Deletes the most recent output.\n     * @param _proposal Represents the output proposal to delete\n     */\n    function deleteL2Output(OutputProposal memory _proposal) external onlyOwner {\n        OutputProposal memory outputToDelete = l2Outputs[latestBlockTimestamp];\n\n        require(\n            _proposal.outputRoot == outputToDelete.outputRoot,\n            \"Can only delete the most recent output.\"\n        );\n        require(_proposal.timestamp == outputToDelete.timestamp, \"\");\n\n        emit l2OutputDeleted(\n            outputToDelete.outputRoot,\n            outputToDelete.timestamp,\n            latestBlockTimestamp\n        );\n\n        delete l2Outputs[latestBlockTimestamp];\n        latestBlockTimestamp = latestBlockTimestamp - SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Computes the timestamp of the next L2 block that needs to be checkpointed.\n     */\n    function nextTimestamp() public view returns (uint256) {\n        return latestBlockTimestamp + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 output proposal given a target L2 block timestamp.\n     * Returns a null output proposal if none is found.\n     * @param _l2Timestamp The L2 block timestamp of the target block.\n     */\n    function getL2Output(uint256 _l2Timestamp) external view returns (OutputProposal memory) {\n        return l2Outputs[_l2Timestamp];\n    }\n\n    /**\n     * @notice Computes the L2 block number given a target L2 block timestamp.\n     * @param _l2timestamp The L2 block timestamp of the target block.\n     */\n    function computeL2BlockNumber(uint256 _l2timestamp) external view returns (uint256) {\n        require(\n            _l2timestamp >= STARTING_BLOCK_TIMESTAMP,\n            \"Timestamp prior to startingBlockTimestamp\"\n        );\n        // For the first block recorded (ie. _l2timestamp = STARTING_BLOCK_TIMESTAMP), the\n        // L2BlockNumber should be HISTORICAL_TOTAL_BLOCKS + 1.\n        unchecked {\n            return\n                HISTORICAL_TOTAL_BLOCKS +\n                ((_l2timestamp - STARTING_BLOCK_TIMESTAMP) / L2_BLOCK_TIME);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Lib_WithdrawalVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/* Library Imports */\nimport {\n    Lib_SecureMerkleTrie\n} from \"@eth-optimism/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport {\n    Lib_CrossDomainUtils\n} from \"@eth-optimism/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\";\n\n/**\n * @title WithdrawalVerifier\n * @notice A library with helper functions for verifying a withdrawal on L1.\n */\nlibrary WithdrawalVerifier {\n    /// @notice A struct containing the elements hashed together to generate the output root.\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 withdrawerStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     * @param _nonce Nonce for the provided message.\n     * @param _sender Message sender address on L2.\n     * @param _target Target address on L1.\n     * @param _value ETH to send to the target.\n     * @param _gasLimit Gas to be forwarded to the target.\n     * @param _data Data to send to the target.\n     */\n    function withdrawalHash(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_nonce, _sender, _target, _value, _gasLimit, _data));\n    }\n\n    /**\n     * @notice Derives the output root corresponding to the elements provided in the proof.\n     * @param _outputRootProof The elements which were hashed together to generate the output root.\n     * @return Whether or not the output root matches the hashed output of the proof.\n     */\n    function _deriveOutputRoot(OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.withdrawerStorageRoot,\n                    _outputRootProof.latestBlockhash\n                )\n            );\n    }\n\n    /**\n     * @notice Verifies a proof that a given withdrawal hash is present in the Withdrawer contract's\n     * withdrawals mapping.\n     * @param _withdrawalHash Keccak256 hash of the withdrawal transaction data.\n     * @param _withdrawerStorageRoot Storage root of the withdrawer predeploy contract.\n     * @param _withdrawalProof Merkle trie inclusion proof for the desired node.\n     * @return Whether or not the inclusion proof was successful.\n     */\n    function _verifyWithdrawalInclusion(\n        bytes32 _withdrawalHash,\n        bytes32 _withdrawerStorageRoot,\n        bytes memory _withdrawalProof\n    ) internal pure returns (bool) {\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                _withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        return\n            Lib_SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _withdrawerStorageRoot\n            );\n    }\n}\n"
    },
    "@eth-optimism/contracts/standards/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.7;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "contracts/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.9;\n\n// FROM: https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol\n// TODO: Just use the original once we get our PR merged.\nlibrary ExcessivelySafeCall {\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value Ether value to send with the call\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/trie/Lib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"./Lib_MerkleTrie.sol\";\n\n/**\n * @title Lib_SecureMerkleTrie\n */\nlibrary Lib_SecureMerkleTrie {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.get(key, _proof, _root);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Computes the secure counterpart to a key.\n     * @param _key Key to get a secure key from.\n     * @return _secureKey Secure version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/Lib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_CrossDomainUtils\n */\nlibrary Lib_CrossDomainUtils {\n    /**\n     * Generates the correct cross domain calldata for a message.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @return ABI encoded cross domain calldata.\n     */\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _message,\n                _messageNonce\n            );\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/trie/Lib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_MerkleTrie\n */\nlibrary Lib_MerkleTrie {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum NodeType {\n        BranchNode,\n        ExtensionNode,\n        LeafNode\n    }\n\n    struct TrieNode {\n        bytes encoded;\n        Lib_RLPReader.RLPItem[] decoded;\n    }\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // TREE_RADIX determines the number of elements per branch node.\n    uint256 constant TREE_RADIX = 16;\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    // Prefixes are prepended to the `path` within a leaf or extension node and\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n    // determined by the number of nibbles within the unprefixed `path`. If the\n    // number of nibbles if even, we need to insert an extra padding nibble so\n    // the resulting prefixed `path` has an even number of nibbles.\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\n    uint8 constant PREFIX_LEAF_EVEN = 2;\n    uint8 constant PREFIX_LEAF_ODD = 3;\n\n    // Just a utility constant. RLP represents `NULL` as 0x80.\n    bytes1 constant RLP_NULL = bytes1(0x80);\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\n\n        return (exists && Lib_BytesUtils.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\n        bool exists = keyRemainder.length == 0;\n\n        require(exists || isFinalNode, \"Provided proof is invalid.\");\n\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n        return (exists, value);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     * @param _proof Inclusion proof to walk through.\n     * @param _key Key to use for the walk.\n     * @param _root Known root of the trie.\n     * @return _pathLength Length of the final path\n     * @return _keyRemainder Portion of the key remaining after the walk.\n     * @return _isFinalNode Whether or not we've hit a dead end.\n     */\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256 _pathLength,\n            bytes memory _keyRemainder,\n            bool _isFinalNode\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        bytes32 currentNodeID = _root;\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 31 bytes aren't hashed.\n                require(\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\n                    \"Invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = bytes32(RLP_NULL);\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength != pathRemainder.length) {\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\n                        currentNodeID = bytes32(RLP_NULL);\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"Received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"Received an unparseable node.\");\n            }\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     * @param _proof RLP-encoded proof to parse.\n     * @return _parsed Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\n        }\n\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the\n     * \"hash\" within the specification, but nodes < 32 bytes are not actually\n     * hashed.\n     * @param _node Node to pull an ID for.\n     * @return _nodeID ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\n        bytes memory nodeID;\n\n        if (_node.length < 32) {\n            // Nodes smaller than 32 bytes are RLP encoded.\n            nodeID = Lib_RLPReader.readRawBytes(_node);\n        } else {\n            // Nodes 32 bytes or larger are hashed.\n            nodeID = Lib_RLPReader.readBytes(_node);\n        }\n\n        return Lib_BytesUtils.toBytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     * @param _node Node to get a path for.\n     * @return _path Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     * @param _node Node to get a value for.\n     * @return _value Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two\n     * nibble arrays.\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     * @return _shared Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256 _shared)\n    {\n        uint256 i = 0;\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n            i++;\n        }\n        return i;\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/utils/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n    /*************\n     * Constants *\n     *************/\n\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"Invalid RLP address value.\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(_in.length > 0, \"RLP item cannot be null.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(_in.length > strLen, \"Invalid RLP short string.\");\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"Invalid RLP short list.\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_DefaultValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_DefaultValues\n */\nlibrary Lib_DefaultValues {\n    // The default x-domain message sender being set to a non-zero value makes\n    // deployment a bit more expensive, but in exchange the refund on every call to\n    // `relayMessage` by the L1 and L2 messengers will be higher.\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/Lib_CrossDomainHashing.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {\n    Lib_CrossDomainUtils\n} from \"@eth-optimism/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\";\nimport { Lib_RLPWriter } from \"@eth-optimism/contracts/libraries/rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title CrossDomainHashing\n * This library is responsible for holding cross domain utility\n * functions.\n * TODO(tynes): merge with Lib_CrossDomainUtils\n * TODO(tynes): fill out more devdocs\n */\nlibrary CrossDomainHashing {\n    /**\n     * @notice Compute the L2 transaction hash given\n     * data about an L1 deposit transaction. This is useful for\n     * environments that do not have access to arbitrary\n     * RLP encoding functionality but have access to the\n     * standard web3 API\n     * TODO: rearrange args in a sane way\n     * @param _l1BlockHash The L1 block hash corresponding to the block\n     * the deposit was included in\n     * @param _logIndex The log index of the event that the deposit was\n     * created from. This can be found on the transaction receipt\n     * @param _from The sender of the deposit\n     * @param _to The L2 contract to be called by the deposit transaction\n     * @param _isCreate Indicates if the deposit creates a contract\n     * @param _mint The amount of ETH being minted by the transaction\n     * @param _value The amount of ETH send in the L2 call\n     * @param _gas The gas limit for the L2 call\n     */\n    function L2TransactionHash(\n        bytes32 _l1BlockHash,\n        uint256 _logIndex,\n        address _from,\n        address _to,\n        bool _isCreate,\n        uint256 _mint,\n        uint256 _value,\n        uint256 _gas,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        bytes memory raw = L2Transaction(\n            _l1BlockHash,\n            _logIndex,\n            _from,\n            _to,\n            _isCreate,\n            _mint,\n            _value,\n            _gas,\n            _data\n        );\n\n        return keccak256(raw);\n    }\n\n    /**\n     * @notice Compute the deposit transaction source hash.\n     * This value ensures that the L2 transaction hash is unique\n     * and deterministic based on L1 execution\n     * @param l1BlockHash The L1 blockhash corresponding to the block including\n     * the deposit\n     * @param logIndex The index of the log that created the deposit transaction\n     */\n    function sourceHash(bytes32 l1BlockHash, uint256 logIndex) internal pure returns (bytes32) {\n        bytes32 depositId = keccak256(abi.encode(l1BlockHash, logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice RLP encode a deposit transaction\n     * This only works for user deposits, not system deposits\n     * TODO: better name + rearrange the input param ordering?\n     */\n    function L2Transaction(\n        bytes32 _l1BlockHash,\n        uint256 _logIndex,\n        address _from,\n        address _to,\n        bool _isCreate,\n        uint256 _mint,\n        uint256 _value,\n        uint256 _gas,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        bytes32 source = sourceHash(_l1BlockHash, _logIndex);\n\n        bytes[] memory raw = new bytes[](7);\n\n        raw[0] = Lib_RLPWriter.writeBytes(bytes32ToBytes(source));\n        raw[1] = Lib_RLPWriter.writeAddress(_from);\n\n        if (_isCreate == true) {\n            require(_to == address(0));\n            raw[2] = Lib_RLPWriter.writeBytes(\"\");\n        } else {\n            raw[2] = Lib_RLPWriter.writeAddress(_to);\n        }\n\n        raw[3] = Lib_RLPWriter.writeUint(_mint);\n        raw[4] = Lib_RLPWriter.writeUint(_value);\n        raw[5] = Lib_RLPWriter.writeUint(_gas);\n        raw[6] = Lib_RLPWriter.writeBytes(_data);\n\n        bytes memory encoded = Lib_RLPWriter.writeList(raw);\n        return abi.encodePacked(uint8(0x7e), encoded);\n    }\n\n    /**\n     * @notice Helper function to turn bytes32 into bytes\n     */\n    function bytes32ToBytes(bytes32 input) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), input) // set the bytes data\n        }\n        return b;\n    }\n\n    /**\n     * @notice Adds the version to the nonce\n     */\n    function addVersionToNonce(uint256 _nonce, uint16 _version)\n        internal\n        pure\n        returns (uint256 nonce)\n    {\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n    }\n\n    /**\n     * @notice Gets the version out of the nonce\n     */\n    function getVersionFromNonce(uint256 _nonce) internal pure returns (uint16 version) {\n        assembly {\n            version := shr(240, _nonce)\n        }\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that\n     * is encoded in the nonce\n     */\n    function getVersionedEncoding(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        uint16 version = getVersionFromNonce(_nonce);\n        if (version == 0) {\n            return getEncodingV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return getEncodingV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        }\n\n        revert(\"Unknown version.\");\n    }\n\n    /**\n     * @notice Compute the cross domain hash based on the versioned nonce\n     */\n    function getVersionedHash(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        uint16 version = getVersionFromNonce(_nonce);\n        if (version == 0) {\n            return getHashV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return getHashV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        }\n\n        revert(\"Unknown version.\");\n    }\n\n    /**\n     * @notice Compute the legacy cross domain serialization\n     */\n    function getEncodingV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return Lib_CrossDomainUtils.encodeXDomainCalldata(_target, _sender, _data, _nonce);\n    }\n\n    /**\n     * @notice Compute the V1 cross domain serialization\n     */\n    function getEncodingV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Compute the legacy hash of a cross domain message\n     */\n    function getHashV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes32) {\n        return keccak256(getEncodingV0(_target, _sender, _data, _nonce));\n    }\n\n    /**\n     * @notice Compute the V1 hash of a cross domain message\n     */\n    function getHashV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return keccak256(getEncodingV1(_nonce, _sender, _target, _value, _gasLimit, _data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { AddressAliasHelper } from \"@eth-optimism/contracts/standards/AddressAliasHelper.sol\";\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\ncontract L2CrossDomainMessenger is CrossDomainMessenger {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice initialize the L2CrossDomainMessenger by giving\n     * it the address of the L1CrossDomainMessenger on L1\n     */\n    function initialize(address _l1CrossDomainMessenger) external {\n        address[] memory blockedSystemAddresses = new address[](2);\n        blockedSystemAddresses[0] = address(this);\n        blockedSystemAddresses[1] = Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER;\n\n        _initialize(_l1CrossDomainMessenger, blockedSystemAddresses);\n    }\n\n    /**\n     * @notice Legacy getter for the remote messenger. This is included\n     * to prevent any existing contracts that relay messages from breaking.\n     * Use `otherMessenger()` for a standard API that works on both\n     * the L1 and L2 cross domain messengers.\n     */\n    function l1CrossDomainMessenger() public returns (address) {\n        return otherMessenger;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Only the L1CrossDomainMessenger can call the\n     * L2CrossDomainMessenger\n     */\n    function _isSystemMessageSender() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == otherMessenger;\n    }\n\n    /**\n     * @notice Sending a message from L2 to L1 involves calling the L2ToL1MessagePasser\n     * where it stores in a storage slot a commitment to the message being\n     * sent to L1. A proof is then verified against that storage slot on L1.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER))\n            .initiateWithdrawal{ value: _value }(_to, _gasLimit, _data);\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\nimport { Burner } from \"./Burner.sol\";\n\n/**\n * @title L2ToL1MessagePasser\n * TODO: should this be renamed to L2OptimismPortal?\n */\ncontract L2ToL1MessagePasser {\n    /**********\n     * Events *\n     **********/\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     * @param nonce Unique value corresponding to each withdrawal.\n     * @param sender The L2 account address which initiated the withdrawal.\n     * @param target The L1 account address the call will be send to.\n     * @param value The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit The minimum amount of gas that must be provided when withdrawing on L1.\n     * @param data The data to be forwarded to the target on L1.\n     */\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /*************\n     * Variables *\n     *************/\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint256 public nonce;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice Allow users to withdraw by sending ETH\n     * directly to this contract.\n     * TODO: maybe this should be only EOA\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, 100000, bytes(\"\"));\n    }\n\n    /**\n     * @notice Initiates a withdrawal to execute on L1.\n     * TODO: message hashes must be migrated since the legacy\n     * hashes are computed differently\n     * @param _target Address to call on L1 execution.\n     * @param _gasLimit GasLimit to provide on L1.\n     * @param _data Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = WithdrawalVerifier.withdrawalHash(\n            nonce,\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit WithdrawalInitiated(nonce, msg.sender, _target, msg.value, _gasLimit, _data);\n        unchecked {\n            ++nonce;\n        }\n    }\n\n    /**\n     * @notice Removes all ETH held in this contract from the state, by deploying a contract which\n     * immediately self destructs.\n     * For simplicity, this call is not incentivized as it costs very little to run.\n     * Inspired by https://etherscan.io/address/0xb69fba56b2e67e7dda61c8aa057886a8d1468575#code\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        new Burner{ value: balance }();\n        emit WithdrawerBalanceBurnt(balance);\n    }\n}\n"
    },
    "contracts/L2/Burner.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title Burner\n * @dev This contract is used to remove ETH from\n * the L2 circulating supply as it is withdrawn.\n */\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Lib_BedrockPredeployAddresses } from \"../libraries/Lib_BedrockPredeployAddresses.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\n/**\n * @title GasPriceOracle\n * @dev This contract maintains the variables responsible for computing the L1\n * portion of the total fee charged on L2. The values stored in the contract\n * are looked up as part of the L2 state transition function and used to compute\n * the total fee paid by the user.\n * The contract exposes an API that is useful for knowing how large the L1\n * portion of their transaction fee will be.\n * This predeploy is found at 0x420000000000000000000000000000000000000F in the\n * L2 state.\n * This contract should be behind an upgradable proxy such that when the gas\n * prices change, the values can be updated accordingly.\n */\ncontract GasPriceOracle is Ownable {\n    /*************\n     * Variables *\n     *************/\n\n    // backwards compatibility\n    uint256 internal spacer0;\n    uint256 internal spacer1;\n\n    // Amortized cost of batch submission per transaction\n    uint256 public overhead;\n    // Value to scale the fee up by\n    uint256 public scalar;\n    // Number of decimals of the scalar\n    uint256 public decimals;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address that will initially own this contract.\n     */\n    constructor(address _owner) Ownable() {\n        transferOwnership(_owner);\n    }\n\n    /**********\n     * Events *\n     **********/\n\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // legacy backwards compat\n    function gasPrice() public returns (uint256) {\n        return block.basefee;\n    }\n\n    function baseFee() public returns (uint256) {\n        return block.basefee;\n    }\n\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Lib_BedrockPredeployAddresses.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * Allows the owner to modify the overhead.\n     * @param _overhead New overhead\n     */\n    // slither-disable-next-line external-function\n    function setOverhead(uint256 _overhead) public onlyOwner {\n        overhead = _overhead;\n        emit OverheadUpdated(_overhead);\n    }\n\n    /**\n     * Allows the owner to modify the scalar.\n     * @param _scalar New scalar\n     */\n    // slither-disable-next-line external-function\n    function setScalar(uint256 _scalar) public onlyOwner {\n        scalar = _scalar;\n        emit ScalarUpdated(_scalar);\n    }\n\n    /**\n     * Allows the owner to modify the decimals.\n     * @param _decimals New decimals\n     */\n    // slither-disable-next-line external-function\n    function setDecimals(uint256 _decimals) public onlyOwner {\n        decimals = _decimals;\n        emit DecimalsUpdated(_decimals);\n    }\n\n    /**\n     * Computes the L1 portion of the fee\n     * based on the size of the RLP encoded tx\n     * and the current l1BaseFee\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return L1 fee that should be paid for the tx\n     */\n    // slither-disable-next-line external-function\n    function getL1Fee(bytes memory _data) public view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**decimals;\n        uint256 unscaled = l1Fee * scalar;\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    // solhint-disable max-line-length\n    /**\n     * Computes the amount of L1 gas used for a transaction\n     * The overhead represents the per batch gas overhead of\n     * posting both transaction and state roots to L1 given larger\n     * batch sizes.\n     * 4 gas for 0 byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33\n     * 16 gas for non zero byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87\n     * This will need to be updated if calldata gas prices change\n     * Account for the transaction being unsigned\n     * Padding is added to account for lack of signature on transaction\n     * 1 byte for RLP V prefix\n     * 1 byte for V\n     * 1 byte for RLP R prefix\n     * 32 bytes for R\n     * 1 byte for RLP S prefix\n     * 32 bytes for S\n     * Total: 68 bytes of padding\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return Amount of L1 gas used for a transaction\n     */\n    // solhint-enable max-line-length\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead;\n        return unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/libraries/Lib_BedrockPredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_BedrockPredeployAddresses\n * TODO: just merge this value into the monorepo\n */\nlibrary Lib_BedrockPredeployAddresses {\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title L1Block\n * @dev This is an L2 predeploy contract that holds values from the L1\n * chain. It can only be updated by a special account that has no private\n * key managed by the L2 system. Transactions sent to this contract can\n * be thought of as \"L2 system transactions\".\n */\ncontract L1Block {\n    /**\n     * @notice Only the Depositor account may call setL1BlockValues().\n     */\n    error OnlyDepositor();\n\n    /**\n     * @notice The depositor account is a special account that sends\n     * transactions to this contract.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @notice Sets the L1 values\n     * @param _number L1 blocknumber\n     * @param _timestamp L1 timestamp\n     * @param _basefee L1 basefee\n     * @param _hash L1 blockhash\n     * @param _sequenceNumber Number of L2 blocks since epoch start\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber\n    ) external {\n        if (msg.sender != DEPOSITOR_ACCOUNT) {\n            revert OnlyDepositor();\n        }\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n    }\n}\n"
    },
    "contracts/L2/L1BlockNumber.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { L1Block } from \"./L1Block.sol\";\nimport { Lib_BedrockPredeployAddresses } from \"../libraries/Lib_BedrockPredeployAddresses.sol\";\n\n/**\n * @title L1BlockNumber\n * @dev L1BlockNumber is a legacy contract that fills the roll of the OVM_L1BlockNumber contract in\n * the old version of the Optimism system. Only necessary for backwards compatibility. If you want\n * to access the L1 block number going forward, you should use the L1Block contract instead.\n *\n * ADDRESS: 0x4200000000000000000000000000000000000013\n */\ncontract L1BlockNumber {\n    receive() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    fallback() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    function getL1BlockNumber() public view returns (uint256) {\n        return L1Block(Lib_BedrockPredeployAddresses.L1_BLOCK_ATTRIBUTES).number();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* Library Imports */\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { OptimismMintableERC20 } from \"./OptimismMintableERC20.sol\";\n\n/**\n * @title StandardBridge\n * This contract can manage a 1:1 bridge between two domains for both\n * ETH (native asset) and ERC20s.\n * This contract should be deployed behind a proxy.\n * TODO: do we want a donateERC20 function as well?\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**********\n     * Events *\n     **********/\n\n    event ETHBridgeInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHBridgeFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeInitiated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeFailed(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /*************\n     * Variables *\n     *************/\n\n    /**\n     * @notice The messenger contract on the same domain\n     */\n    CrossDomainMessenger public messenger;\n\n    /**\n     * @notice The corresponding bridge on the other domain\n     */\n    StandardBridge public otherBridge;\n\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this\n     * is not safe against contracts calling code during their constructor\n     */\n    modifier onlyEOA() {\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is the messenger, and that\n     * it has the l2Sender value set to the address of the remote Token Bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(messenger) &&\n                messenger.xDomainMessageSender() == address(otherBridge),\n            \"Could not authenticate bridge message.\"\n        );\n        _;\n    }\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Function can only be called by self.\");\n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice Send ETH to this contract. This is used during upgrades\n     */\n    function donateETH() external payable {}\n\n    /**\n     * @notice EOAs can simply send ETH to this contract to have it be deposited\n     * to L2 through the standard bridge.\n     */\n    receive() external payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, 200_000, bytes(\"\"));\n    }\n\n    /**\n     * @notice Send ETH to the message sender on the remote domain\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _data) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _data);\n    }\n\n    /**\n     * @notice Send ETH to a specified account on the remote domain\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _data);\n    }\n\n    /**\n     * @notice Send an ERC20 to the message sender on the remote domain\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) public virtual onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _data\n        );\n    }\n\n    /**\n     * @notice Send an ERC20 to a specified account on the remote domain\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) public virtual {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _data\n        );\n    }\n\n    /**\n     * @notice Finalize an ETH sending transaction sent from a remote domain\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"Amount sent does not match amount required.\");\n        require(_to != address(this), \"Cannot send to self.\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _data);\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalize an ERC20 sending transaction sent from a remote domain\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public onlyOtherBridge {\n        try this.completeOutboundTransfer(_localToken, _remoteToken, _to, _amount) {\n            emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _data);\n        } catch {\n            // Something went wrong during the bridging process, return to sender.\n            // Can happen if a bridge UI specifies the wrong L2 token.\n            _initiateBridgeERC20Unchecked(\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                0, // _minGasLimit, 0 is fine here\n                _data\n            );\n            emit ERC20BridgeFailed(_localToken, _remoteToken, _from, _to, _amount, _data);\n        }\n    }\n\n    function completeOutboundTransfer(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount\n    ) public onlySelf {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"Local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"Wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Initialize the StandardBridge contract with the address of\n     * the messenger on the same domain as well as the address of the bridge\n     * on the remote domain\n     */\n    function _initialize(address payable _messenger, address payable _otherBridge) internal {\n        require(address(messenger) == address(0), \"Contract has already been initialized.\");\n\n        messenger = CrossDomainMessenger(_messenger);\n        otherBridge = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Bridge ETH to the remote chain through the messenger\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _data\n    ) internal {\n        emit ETHBridgeInitiated(_from, _to, _amount, _data);\n\n        messenger.sendMessage{ value: _amount }(\n            address(otherBridge),\n            abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _data),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Bridge an ERC20 to the remote chain through the messengers\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) internal {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"Local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"Wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).burn(msg.sender, _amount);\n        } else {\n            // TODO: Do we need to confirm that the transfer was successful?\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        _initiateBridgeERC20Unchecked(\n            _localToken,\n            _remoteToken,\n            _from,\n            _to,\n            _amount,\n            _minGasLimit,\n            _data\n        );\n    }\n\n    /**\n     * @notice Bridge an ERC20 to the remote chain through the messengers\n     */\n    function _initiateBridgeERC20Unchecked(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) internal {\n        messenger.sendMessage(\n            address(otherBridge),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _data\n            ),\n            _minGasLimit\n        );\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _data);\n    }\n\n    /**\n     * Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\n     * Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     * @return True if the token is an OptimismMintableERC20.\n     */\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\n        // 0x1d1d8b63 is mint ^ burn ^ l1Token\n        return ERC165Checker.supportsInterface(_token, 0x1d1d8b63);\n    }\n\n    /**\n     * Checks if the \"other token\" is the correct pair token for the OptimismMintableERC20.\n     *\n     * @param _mintableToken OptimismMintableERC20 to check against.\n     * @param _otherToken Pair token to check.\n     * @return True if the other token is the correct pair token for the OptimismMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == OptimismMintableERC20(_mintableToken).l1Token();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title OptimismMintableERC20\n * This contract represents the remote representation\n * of an ERC20 token. It is linked to the address of\n * a token in another domain and tokens can be locked\n * in the StandardBridge which will mint tokens in the\n * other domain.\n */\ncontract OptimismMintableERC20 is ERC20 {\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n\n    /**\n     * @notice The address of the token in the remote domain\n     */\n    address public remoteToken;\n\n    /**\n     * @notice The address of the bridge responsible for\n     * minting. It is in the same domain.\n     */\n    address public bridge;\n\n    /**\n     * @param _bridge Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        remoteToken = _remoteToken;\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Returns the corresponding L1 token address.\n     * This is a legacy function and wraps the remoteToken value.\n     */\n    function l1Token() public view returns (address) {\n        return remoteToken;\n    }\n\n    /**\n     * @notice The address of the bridge contract\n     * responsible for minting tokens. This is a legacy\n     * getter function\n     */\n    function l2Bridge() public view returns (address) {\n        return bridge;\n    }\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @notice ERC165\n     */\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 iface2 = this.l1Token.selector ^ this.mint.selector ^ this.burn.selector;\n        bytes4 iface3 = this.remoteToken.selector ^ this.mint.selector ^ this.burn.selector;\n        return _interfaceId == iface1 || _interfaceId == iface3 || _interfaceId == iface2;\n    }\n\n    /**\n     * @notice The bridge can mint tokens\n     */\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual onlyBridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice The bridge can burn tokens\n     */\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual onlyBridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @title L2StandardBridge\n * @dev This contract is an L2 predeploy that is responsible for facilitating\n * deposits of tokens from L1 to L2.\n * TODO: ensure that this has 1:1 backwards compatibility\n */\ncontract L2StandardBridge is StandardBridge {\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice Initialize the L2StandardBridge. This must only be callable\n     * once. `_initialize` ensures this.\n     */\n    function initialize(address payable _otherBridge) public {\n        _initialize(payable(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER), _otherBridge);\n    }\n\n    /**\n     * @notice Withdraw tokens to self on L1\n     * @param _l2Token The L2 token address to withdraw\n     * @param _amount The amount of L2 token to withdraw\n     * @param _minGasLimit The min gas limit in the withdrawing call\n     * @param _data Additional calldata to pass along\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) external payable virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _data);\n    }\n\n    /**\n     * @notice Withdraw tokens to an address on L1\n     * @param _l2Token The L2 token address to withdraw\n     * @param _to The L1 account to withdraw to\n     * @param _amount The amount of L2 token to withdraw\n     * @param _minGasLimit The min gas limit in the withdrawing call\n     * @param _data Additional calldata to pass along\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) external payable virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _data);\n    }\n\n    /**\n     * @notice Finalize the L1 to L2 deposit. This should only be callable by\n     * a deposit through the L1StandardBridge.\n     * @param _l1Token The L1 token address\n     * @param _l2Token The corresponding L2 token address\n     * @param _from The sender of the tokens\n     * @param _to The recipient of the tokens\n     * @param _amount The amount of tokens\n     * @param _data Additional calldata\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable virtual {\n        if (_l1Token == address(0) && _l2Token == Lib_PredeployAddresses.OVM_ETH) {\n            finalizeBridgeETH(_from, _to, _amount, _data);\n        } else {\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _data);\n        }\n        emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Handle withdrawals, taking into account the legacy form of ETH\n     * when it was represented as an ERC20 at the OVM_ETH contract.\n     * TODO: require(msg.value == _value) for OVM_ETH case?\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) internal {\n        address l1Token = OptimismMintableERC20(_l2Token).l1Token();\n        if (_l2Token == Lib_PredeployAddresses.OVM_ETH) {\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _data);\n        } else {\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _data);\n        }\n        emit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount, _data);\n    }\n}\n"
    },
    "contracts/L2/SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardBridge } from \"./L2StandardBridge.sol\";\n\n/**\n * @title SequencerFeeVault\n * @dev Simple holding contract for fees paid to the Sequencer\n */\ncontract SequencerFeeVault {\n    /*************\n     * Constants *\n     *************/\n\n    // Minimum ETH balance that can be withdrawn in a single withdrawal.\n    uint256 public constant MIN_WITHDRAWAL_AMOUNT = 15 ether;\n\n    /*************\n     * Variables *\n     *************/\n\n    // Address on L1 that will hold the fees once withdrawn. Dynamically\n    // initialized in the genesis state\n    address public l1FeeWallet;\n\n    /************\n     * Fallback *\n     ************/\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {}\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // slither-disable-next-line external-function\n    function withdraw() public {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            // solhint-disable-next-line max-line-length\n            \"OVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 balance = address(this).balance;\n\n        L2StandardBridge(payable(Lib_PredeployAddresses.L2_STANDARD_BRIDGE)).withdrawTo{\n            value: balance\n        }(Lib_PredeployAddresses.OVM_ETH, l1FeeWallet, balance, 0, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n/**\n * @title OptimismMintableTokenFactory\n * @dev Factory contract for creating standard remote token representations of\n * local ERC20s. This can be used to bridge native L1 ERC20s to L2 or native L2\n * ERC20s to L1. The tokens created through this factory are meant to operate\n * with the StandardBridge contract for deposits/withdrawals.\n * This contract is a predeploy on L2 at 0x4200000000000000000000000000000000000012\n * TODO: deploy to a deterministic address on L1 networks?\n * TODO: should this be extended for L1/L2 with hardcoded values in\n * the base contract's initialize?\n */\ncontract OptimismMintableTokenFactory {\n    event StandardL2TokenCreated(address indexed _remoteToken, address indexed _localToken);\n    event OptimismMintableTokenCreated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address _deployer\n    );\n\n    address public bridge;\n\n    /**\n     * @dev Initialize the factory\n     * On L2 _bridge should be Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n     * On L1 _bridge should be the L1StandardBridge\n     */\n    function initialize(address _bridge) public {\n        require(bridge == address(0), \"Already initialized.\");\n        bridge = _bridge;\n    }\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    function createStandardL2Token(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(_remoteToken != address(0), \"Must provide L1 token address\");\n        require(bridge != address(0), \"Must initialize first\");\n\n        OptimismMintableERC20 localToken = new OptimismMintableERC20(\n            bridge,\n            _remoteToken,\n            _name,\n            _symbol\n        );\n\n        // Legacy Purposes\n        emit StandardL2TokenCreated(_remoteToken, address(localToken));\n        emit OptimismMintableTokenCreated(_remoteToken, address(localToken), msg.sender);\n\n        return address(localToken);\n    }\n}\n"
    },
    "contracts/L2/OVM_ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @title OVM_ETH\n * @dev Deprecated contract that used to hold user ETH balances\n */\ncontract OVM_ETH is OptimismMintableERC20 {\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor()\n        OptimismMintableERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"ETH\")\n    {}\n\n    function mint(address _to, uint256 _amount) public virtual override {\n        revert(\"OVM_ETH: mint is disabled\");\n    }\n\n    function burn(address _from, uint256 _amount) public virtual override {\n        revert(\"OVM_ETH: burn is disabled\");\n    }\n\n    function transfer(address _recipient, uint256 _amount) public virtual override returns (bool) {\n        revert(\"OVM_ETH: transfer is disabled\");\n    }\n\n    function approve(address _spender, uint256 _amount) public virtual override returns (bool) {\n        revert(\"OVM_ETH: approve is disabled\");\n    }\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        revert(\"OVM_ETH: transferFrom is disabled\");\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"OVM_ETH: increaseAllowance is disabled\");\n    }\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"OVM_ETH: decreaseAllowance is disabled\");\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {\n    Lib_PredeployAddresses\n} from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @title L1StandardBridge\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n */\ncontract L1StandardBridge is StandardBridge {\n    /**********\n     * Events *\n     **********/\n\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev initialize the L1StandardBridge with the address of the\n     *      messenger in the same domain\n     */\n    function initialize(address payable _messenger) public {\n        _initialize(_messenger, payable(Lib_PredeployAddresses.L2_STANDARD_BRIDGE));\n    }\n\n    /**\n     * @dev Get the address of the corresponding L2 bridge contract.\n     *      This is a legacy getter, provided for backwards compatibility.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address) {\n        return address(otherBridge);\n    }\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _minGasLimit limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _minGasLimit, bytes calldata _data) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _data);\n    }\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _minGasLimit Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _data);\n    }\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _minGasLimit limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _data\n        );\n    }\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _minGasLimit Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) external virtual {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _minGasLimit, _data);\n    }\n\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable onlyOtherBridge {\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);\n        finalizeBridgeETH(_from, _to, _amount, _data);\n    }\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyOtherBridge {\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _minGasLimit,\n        bytes memory _data\n    ) internal {\n        emit ETHDepositInitiated(_from, _to, msg.value, _data);\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _data);\n    }\n\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _data\n    ) internal {\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _data);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
